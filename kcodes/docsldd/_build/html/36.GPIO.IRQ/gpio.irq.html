<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>36. Handle GPIO inputs using IRQ’s &mdash; LDD DOCS 1.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="DOCS FOR [ LDD ] SOURCE FILE’s:" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            LDD DOCS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">GPIO IRQ's</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">36. Handle GPIO inputs using IRQ’s</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#gpio-linux-device-driver">1. <strong>GPIO Linux Device Driver</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">2. <strong>Prerequisites</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-required">3. <strong>Hardware Required</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#bring-up-raspberry-pi">4. <strong>Bring up Raspberry PI</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-the-input-gpio-in-linux-kernel">5. <strong>Accessing the input GPIO in Linux Kernel</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpio-apis-in-linux-kernel">6. <strong>GPIO APIs in Linux kernel</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-programming">7. <strong>Example Programming</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing-the-device-driver">8. <strong>Testing the Device Driver</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-video">9. <strong>Output Video</strong></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">LDD DOCS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">36. Handle GPIO inputs using IRQ’s</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/36.GPIO.IRQ/gpio.irq.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="handle-gpio-inputs-using-irq-s">
<h1>36. Handle GPIO inputs using IRQ’s<a class="headerlink" href="#handle-gpio-inputs-using-irq-s" title="Permalink to this heading"></a></h1>
<section id="gpio-linux-device-driver">
<h2>1. <strong>GPIO Linux Device Driver</strong><a class="headerlink" href="#gpio-linux-device-driver" title="Permalink to this heading"></a></h2>
</section>
<section id="prerequisites">
<h2>2. <strong>Prerequisites</strong><a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Understanding GPIO</p></li>
<li><p>Interrupts in Linux Kernel</p></li>
<li><p>Interrupts example in Linux kernel</p></li>
</ul>
</section>
<section id="hardware-required">
<h2>3. <strong>Hardware Required</strong><a class="headerlink" href="#hardware-required" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Raspberry Pi</p></li>
<li><p>Breadboard</p></li>
<li><p>Resistor</p></li>
<li><p>LED</p></li>
<li><p>Push-button (In our tutorial, we have used a vibration sensor as an input device)</p></li>
</ul>
</section>
<section id="bring-up-raspberry-pi">
<h2>4. <strong>Bring up Raspberry PI</strong><a class="headerlink" href="#bring-up-raspberry-pi" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Install Raspberry Pi OS (32-bit) with desktop in the SD card.</p></li>
<li><p>Then install the kernel header using sudo apt install raspberrypi-kernel-headers</p></li>
</ul>
</section>
<section id="accessing-the-input-gpio-in-linux-kernel">
<h2>5. <strong>Accessing the input GPIO in Linux Kernel</strong><a class="headerlink" href="#accessing-the-input-gpio-in-linux-kernel" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Verify the GPIO is valid or not.</p></li>
<li><p>If it is valid, then you can request the GPIO from the Kernel GPIO subsystem.</p></li>
<li><p>Set the direction of the GPIO as an input</p></li>
<li><p>Set the debounce-interval</p></li>
<li><p>Read the GPIO.</p></li>
<li><p>You enable IRQ also for edge/level triggered if you need it.</p></li>
<li><p>Then release the GPIO while exiting the driver or once you are done.</p></li>
</ul>
</section>
<section id="gpio-apis-in-linux-kernel">
<h2>6. <strong>GPIO APIs in Linux kernel</strong><a class="headerlink" href="#gpio-apis-in-linux-kernel" title="Permalink to this heading"></a></h2>
<p>We have seen almost all the APIs in our last tutorial.
So, please go through that.
Here we will see the APIs that we have missed in that last tutorial.</p>
<blockquote>
<div><ol class="arabic">
<li><p><strong>Set the debounce-interval</strong></p>
<blockquote>
<div><p>The below API is used for sets debounce time for a GPIO.
Right now raspberry pi is not supporting that.
That’s why we have commented on that line in our source code.
Instead, we used some software hack to eliminate multiple times IRQ being
called for a single rising edge transition. You can remove the software hack
and uncomment that gpio_set_debounce() if your microcontroller supports this.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">gpiod_set_debounce</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">debounce</span><span class="p">);</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">gpio</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="n">GPIO</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">debounce</span><span class="w"> </span><span class="n">value</span><span class="p">.</span>
<span class="nl">debounce</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="n">Delay</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">debounce</span><span class="p">.</span>
<span class="nl">retrun</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">success</span><span class="p">.</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="o">&lt;</span><span class="mf">0.</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Get the IRQ number for the GPIO</strong></p>
<blockquote>
<div><p>Using the below API, you can get the IRQ number for the specific GPIO.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gpio_to_irq</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gpio</span><span class="p">);</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">gpio</span><span class="w"> </span><span class="p">:</span><span class="w">  </span><span class="n">GPIO</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">IRQ</span><span class="w"> </span><span class="n">number</span><span class="p">.</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Request the IRQ</strong></p>
<blockquote>
<div><p>Here is where you need to register the GPIO IRQ number and its handler
to the Linux Interrupts with the proper interrupt flags. You can find
the details regarding requesting the GPIO here. Please note that you
have to free the IRQ once you are done with the interrupt.</p>
</div></blockquote>
</li>
<li><p><strong>Interrupt Flags</strong></p>
<blockquote>
<div><p>While registering the GPIO interrupt using request_irq() you can use
any one of the flags based on your need.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">IRQF_TRIGGER_RISING</span>
<span class="n">IRQF_TRIGGER_FALLING</span>
<span class="n">IRQF_TRIGGER_HIGH</span>
<span class="n">IRQF_TRIGGER_LOW</span>
</pre></div>
</div>
<p>So we are all set. Let’s jump into the programming.</p>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</section>
<section id="example-programming">
<h2>7. <strong>Example Programming</strong><a class="headerlink" href="#example-programming" title="Permalink to this heading"></a></h2>
<blockquote>
<div><blockquote>
<div><p>In this example, I have just taken the 2 GPIOs. One is for the input and
one is for the output.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>GPIO<span class="w"> </span><span class="m">21</span><span class="w"> </span>–<span class="w"> </span>OUTPUT
GPIO<span class="w"> </span><span class="m">25</span><span class="w"> </span>–<span class="w"> </span>INPUT
</pre></div>
</div>
<p>LED has been connected to the OUTPUT pin (GPIO 21) and the Vibration sensor
has been connected to the INPUT pin (GPIO 25). You can connect the
push-button also into the INPUT pin.</p>
<p>So the concept is whenever the vibration is detected, it will toggle the
LED. Just simple right. Let’s write the code.</p>
</div></blockquote>
<ol class="arabic">
<li><p><strong>Connection Diagram</strong></p></li>
<li><p><strong>Driver Source Code</strong></p>
<blockquote>
<div><p>source:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/***************************************************************************//**</span>
<span class="cm">*  \file       driver.c</span>
<span class="cm">*</span>
<span class="cm">*  \details    Simple GPIO driver explanation (GPIO Interrupt)</span>
<span class="cm">*</span>
<span class="cm">*  \author     EmbeTronicX</span>
<span class="cm">*</span>
<span class="cm">*  \Tested with Linux raspberrypi 5.4.51-v7l+</span>
<span class="cm">*</span>
<span class="cm">*******************************************************************************/</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/kernel.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/init.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/fs.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/cdev.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/device.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/delay.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="c1">  //copy_to/from_user()</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/gpio.h&gt;</span><span class="c1">     //GPIO</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/interrupt.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/err.h&gt;</span>
<span class="cm">/* Since debounce is not supported in Raspberry pi, I have addded this to disable</span>
<span class="cm">** the false detection (multiple IRQ trigger for one interrupt).</span>
<span class="cm">** Many other hardware supports GPIO debounce, I don&#39;t want care about this even</span>
<span class="cm">** if this has any overhead. Our intention is to explain the GPIO interrupt.</span>
<span class="cm">** If you want to disable this extra coding, you can comment the below macro.</span>
<span class="cm">** This has been taken from : https://raspberrypi.stackexchange.com/questions/8544/gpio-interrupt-debounce</span>
<span class="cm">**</span>
<span class="cm">** If you want to use Hardaware Debounce, then comment this EN_DEBOUNCE.</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="cp">#define EN_DEBOUNCE</span>

<span class="cp">#ifdef EN_DEBOUNCE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/jiffies.h&gt;</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">jiffies</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">old_jiffie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="c1">//LED is connected to this GPIO</span>
<span class="cp">#define GPIO_21_OUT (21)</span>

<span class="c1">//LED is connected to this GPIO</span>
<span class="cp">#define GPIO_25_IN  (25)</span>

<span class="c1">//GPIO_25_IN value toggle</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">led_toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">//This used for storing the IRQ number for the GPIO</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">GPIO_irqNumber</span><span class="p">;</span>

<span class="c1">//Interrupt handler for GPIO 25. This will be called whenever there is a raising edge detected.</span>
<span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">gpio_irq_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef EN_DEBOUNCE</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">old_jiffie</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">diff</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">old_jiffie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="n">led_toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">led_toggle</span><span class="p">);</span><span class="w">                             </span><span class="c1">// toggle the old value</span>
<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">,</span><span class="w"> </span><span class="n">led_toggle</span><span class="p">);</span><span class="w">                      </span><span class="c1">// toggle the GPIO_21_OUT</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Interrupt Occurred : GPIO_21_OUT : %d &quot;</span><span class="p">,</span><span class="n">gpio_get_value</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">));</span>
<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">dev_t</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">class</span><span class="w"> </span><span class="o">*</span><span class="n">dev_class</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cdev</span><span class="w"> </span><span class="n">etx_cdev</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">etx_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__exit</span><span class="w"> </span><span class="nf">etx_driver_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*************** Driver functions **********************/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">etx_open</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">etx_release</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">etx_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span>
<span class="w">                </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">off</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">etx_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">off</span><span class="p">);</span>
<span class="cm">/******************************************************/</span>

<span class="c1">//File operation structure</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_operations</span><span class="w"> </span><span class="n">fops</span><span class="w"> </span><span class="o">=</span>
<span class="p">{</span>
<span class="p">.</span><span class="n">owner</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">.</span><span class="n">read</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">etx_read</span><span class="p">,</span>
<span class="p">.</span><span class="n">write</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">etx_write</span><span class="p">,</span>
<span class="p">.</span><span class="n">open</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">etx_open</span><span class="p">,</span>
<span class="p">.</span><span class="n">release</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">etx_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">** This function will be called when we open the Device file</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">etx_open</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device File Opened...!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** This function will be called when we close the Device file</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">etx_release</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device File Closed...!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** This function will be called when we read the Device file</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">etx_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span>
<span class="w">                </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">gpio_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">//reading GPIO value</span>
<span class="n">gpio_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpio_get_value</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">);</span>

<span class="c1">//write to user</span>
<span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio_state</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: Not all the bytes have been copied to user</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Read function : GPIO_21 = %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">gpio_state</span><span class="p">);</span>

<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** This function will be called when we write the Device file</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">etx_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">rec_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">copy_from_user</span><span class="p">(</span><span class="w"> </span><span class="n">rec_buf</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: Not all the bytes have been copied from user</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Write Function : GPIO_21 Set = %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rec_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rec_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//set the GPIO value to HIGH</span>
<span class="w">    </span><span class="n">gpio_set_value</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rec_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//set the GPIO value to LOW</span>
<span class="w">    </span><span class="n">gpio_set_value</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown command : Please provide either 1 or 0 </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Module Init function</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">etx_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*Allocating Major number*/</span>
<span class="k">if</span><span class="p">((</span><span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;etx_Dev&quot;</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot allocate major number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_unreg</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Major = %d Minor = %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span><span class="w"> </span><span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

<span class="cm">/*Creating cdev structure*/</span>
<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etx_cdev</span><span class="p">,</span><span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span>

<span class="cm">/*Adding character device to the system*/</span>
<span class="k">if</span><span class="p">((</span><span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etx_cdev</span><span class="p">,</span><span class="n">dev</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot add the device to the system</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_del</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Creating struct class*/</span>
<span class="k">if</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span><span class="s">&quot;etx_class&quot;</span><span class="p">))){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot create the struct class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_class</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Creating device*/</span>
<span class="k">if</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device_create</span><span class="p">(</span><span class="n">dev_class</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dev</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="s">&quot;etx_device&quot;</span><span class="p">))){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Cannot create the Device </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_device</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Output GPIO configuration</span>
<span class="c1">//Checking the GPIO is valid or not</span>
<span class="k">if</span><span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;GPIO %d is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_21_OUT</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_device</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Requesting the GPIO</span>
<span class="k">if</span><span class="p">(</span><span class="n">gpio_request</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">,</span><span class="s">&quot;GPIO_21_OUT&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: GPIO %d request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_21_OUT</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_gpio_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//configure the GPIO as output</span>
<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">//Input GPIO configuratioin</span>
<span class="c1">//Checking the GPIO is valid or not</span>
<span class="k">if</span><span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;GPIO %d is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_gpio_in</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Requesting the GPIO</span>
<span class="k">if</span><span class="p">(</span><span class="n">gpio_request</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">,</span><span class="s">&quot;GPIO_25_IN&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: GPIO %d request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_gpio_in</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//configure the GPIO as input</span>
<span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">** I have commented the below few lines, as gpio_set_debounce is not supported</span>
<span class="cm">** in the Raspberry pi. So we are using EN_DEBOUNCE to handle this in this driver.</span>
<span class="cm">*/</span>
<span class="cp">#ifndef EN_DEBOUNCE</span>
<span class="c1">//Debounce the button with a delay of 200ms</span>
<span class="k">if</span><span class="p">(</span><span class="n">gpio_set_debounce</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: gpio_set_debounce - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//goto r_gpio_in;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="c1">//Get the IRQ number for our GPIO</span>
<span class="n">GPIO_irqNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpio_to_irq</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;GPIO_irqNumber = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_irqNumber</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">GPIO_irqNumber</span><span class="p">,</span><span class="w">             </span><span class="c1">//IRQ number</span>
<span class="w">                </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">gpio_irq_handler</span><span class="p">,</span><span class="w">   </span><span class="c1">//IRQ handler</span>
<span class="w">                </span><span class="n">IRQF_TRIGGER_RISING</span><span class="p">,</span><span class="w">        </span><span class="c1">//Handler will be called in raising edge</span>
<span class="w">                </span><span class="s">&quot;etx_device&quot;</span><span class="p">,</span><span class="w">               </span><span class="c1">//used to identify the device name using this IRQ</span>
<span class="w">                </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">                    </span><span class="c1">//device id for shared IRQ</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;my_device: cannot register IRQ &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">r_gpio_in</span><span class="p">;</span>
<span class="p">}</span>



<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device Driver Insert...Done!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="nl">r_gpio_in</span><span class="p">:</span>
<span class="n">gpio_free</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="nl">r_gpio_out</span><span class="p">:</span>
<span class="n">gpio_free</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">);</span>
<span class="nl">r_device</span><span class="p">:</span>
<span class="n">device_destroy</span><span class="p">(</span><span class="n">dev_class</span><span class="p">,</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">r_class</span><span class="p">:</span>
<span class="n">class_destroy</span><span class="p">(</span><span class="n">dev_class</span><span class="p">);</span>
<span class="nl">r_del</span><span class="p">:</span>
<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etx_cdev</span><span class="p">);</span>
<span class="nl">r_unreg</span><span class="p">:</span>
<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Module exit function</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__exit</span><span class="w"> </span><span class="nf">etx_driver_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">free_irq</span><span class="p">(</span><span class="n">GPIO_irqNumber</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">gpio_free</span><span class="p">(</span><span class="n">GPIO_25_IN</span><span class="p">);</span>
<span class="n">gpio_free</span><span class="p">(</span><span class="n">GPIO_21_OUT</span><span class="p">);</span>
<span class="n">device_destroy</span><span class="p">(</span><span class="n">dev_class</span><span class="p">,</span><span class="n">dev</span><span class="p">);</span>
<span class="n">class_destroy</span><span class="p">(</span><span class="n">dev_class</span><span class="p">);</span>
<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etx_cdev</span><span class="p">);</span>
<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device Driver Remove...Done!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">etx_driver_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">etx_driver_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;EmbeTronicX &lt;embetronicx@gmail.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;A simple device driver - GPIO Driver (GPIO Interrupt) &quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;1.33&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Makefile</strong></p>
<blockquote>
<div><p>Makefile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>obj-m += driver.o

KDIR = /lib/modules/$(shell uname -r)/build


all:
    make -C $(KDIR)  M=$(shell pwd) modules

clean:
    make -C $(KDIR)  M=$(shell pwd) clean
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</section>
<section id="testing-the-device-driver">
<h2>8. <strong>Testing the Device Driver</strong><a class="headerlink" href="#testing-the-device-driver" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>Build the driver by using Makefile (sudo make)
Load the driver using sudo insmod driver.ko
Just press the button or vibrate the vibration sensor.
That output LED should be toggled.</p>
</div></blockquote>
</section>
<section id="output-video">
<h2>9. <strong>Output Video</strong><a class="headerlink" href="#output-video" title="Permalink to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="DOCS FOR [ LDD ] SOURCE FILE’s:" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, sha.dev.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>